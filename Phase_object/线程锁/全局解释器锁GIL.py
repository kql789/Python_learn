# @Author : Kql
# @Time : 2023/6/8 17:42
import threading

'''
既然介绍了多线程和线程锁，那就不得不提及Python的GIL问题。

在大多数环境中，单核CPU情况下，本质上某一时刻只能有一个线程被执行，多核CPU时则 可以支持多个线程同时执行。
但是在Python中，无论CPU有多少核，同时只能执行一个线程。这是由于GIL的存在导致的。

GIL的全称是Global Interpreter Lock(全局解释器锁)，是Python设计之初为了数据安全所做的决定。
Python中的某个线程想要执行，必须先拿到GIL。可以把GIL看作是执行任务的“通行证”，并且在一个Python进程中，
GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。GIL只在CPython解释器中才有，
因为CPython调用的是c语言的原生线程，不能直接操作cpu，只能利用GIL保证同一时间只能有一个线程拿到数据。
在PyPy和JPython中没有GIL。
'''

'''
Python多线程的工作流程：

拿到公共数据
申请GIL
Python解释器调用操作系统原生线程
cpu执行运算
当该线程执行一段时间消耗完，无论任务是否已经执行完毕，都会释放GIL
下一个被CPU调度的线程重复上面的过程
'''

'''
Python针对不同类型的任务，多线程执行效率是不同的：
对于CPU密集型任务(各种循环处理、计算等等)，由于计算工作多，ticks计数很快就会达到阈值，
然后触发GIL的释放与再竞争（多个线程来回切换是需要消耗资源的），所以Python下的多线程对CPU密集型任务并不友好。

IO密集型任务(文件处理、网络通信等涉及数据读写的操作)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，
造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。
所以Python的多线程对IO密集型任务比较友好。
'''

'''
为什么不能去掉GIL？

首先，在早期的Python解释器依赖较多的全局状态，传承下来，使得想要移除当今的GIL变得更加困难。其次，对于程序员而言，
仅仅是理解GIL的实现就需要对操作系统设计、多线程编程、C语言、解释器设计和CPython解释器的实现有着非常彻底的理解，
更不用说对它进行修改删除了。总之，整体技术难度大，会对当前内部框架产生根本性的影响，牵一发而动全身。

在1999年，针对Python1.5，一个叫做“freethreading”的补丁已经尝试移除GIL，用细粒度的锁来代替。然而，
GIL的移除给单线程程序的执行速度带来了一定的负面影响。当用单线程执行时，速度大约降低了40%。
虽然使用两个线程时在速度上得到了提高，但这个提高并没有随着核数的增加而线性增长。因此这个补丁没有被采纳。

虽然，在Python的不同解释器实现中，如PyPy就移除了GIL，其执行速度更快（不单单是去除GIL的原因）。
但是，我们通常使用的CPython解释器版本占有着统治地位的使用量，所以，你懂的。

'''

'''
Python中想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行。
在Python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。同时建议在IO密集型任务中使用多线程，
在计算密集型任务中使用多进程。另外，深入研究Python的协程机制，你会有惊喜的。
'''
